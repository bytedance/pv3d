# Copyright 2022 ByteDance and/or its affiliates.
#
# Copyright (2022) PV3D Authors
#
# ByteDance, its affiliates and licensors retain all intellectual
# property and proprietary rights in and to this material, related
# documentation and any modifications thereto. Any use, reproduction,
# disclosure or distribution of this material and related documentation
# without an express license agreement from ByteDance or
# its affiliates is strictly prohibited.


import torch
import cv2
import argparse
import numpy as np
import torch.nn.functional as F
from tqdm import tqdm
from lib.utils.chamfer_distance.chamfer import chamfer_distance
from lib.utils.render_utils import xyz2mesh


def compute_chamfer_distance(args, num_videos=1000, num_frames=4, visualize=False):
    dists = []
    dists_single_frame = []
    dists_cross_frame = []
    pairs = [[0, 2], [3, 1], [0, 1], [3, 2]]
    for idx in tqdm(range(num_videos)):
        cache = torch.load(f"{args.path}/{idx:04d}.pt")
        points = cache["xyz"].cuda()
        weights = cache["weights_total"].cuda()
        for i, pair in enumerate(pairs):
            if visualize:
                xyz = points[i].cpu()
                mesh = xyz2mesh(xyz.permute(2, 0, 1).unsqueeze(0))
                with open('save/debug/test.obj', 'w') as f:
                    mesh.export(f, file_type='obj')
                mask = (weights[i] > 0.99)
                img = mask.reshape(64, 64, 1).repeat(1, 1, 3).to(torch.uint8).mul(255).cpu().numpy()
                cv2.imwrite("save/debug/depth.jpg", img)
            H, W = points[pair[0]].shape[:2]
            x = points[pair[0]].clone().reshape(1, H*W, 3)
            y = points[pair[1]].clone().reshape(1, H*W, 3)
            x_mask = (weights[pair[0]] > 0.5).reshape(1, H*W)
            y_mask = (weights[pair[1]] > 0.5).reshape(1, H*W)
            dist, _ = chamfer_distance(x, y, x_weight_mask=x_mask, y_weight_mask=y_mask, batch_reduction=None, point_reduction="median")
            if torch.isnan(dist).any().item():
                # skip nan generated by failure cases
                print("skip nan")
                continue
            dists.append(dist.item())
            if i < 2:
                dists_single_frame.append(dist.item())
            else:
                dists_cross_frame.append(dist.item())
    print("overall avg chamfer dist:", np.sum(dists))
    return np.sum(dists)


if __name__ == "__main__":
    parser = argparse.ArgumentParser("compute chamfer distance")
    parser.add_argument("--path", type=str, required=True)
    args = parser.parse_args()
    compute_chamfer_distance(args)